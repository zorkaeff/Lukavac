<!DOCTYPE html>
<!-- Version 2.0 - Fixed duplicate globalQuestionIndex - 2026-01-25 -->
<html lang="hr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lukavac - Admin Panel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #f5e6d3 0%, #d97706 50%, #f5e6d3 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .card {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .btn-primary {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            transition: all 0.3s;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(249, 115, 22, 0.4);
        }
    </style>
</head>
<body class="p-4">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="card p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-4xl font-bold" style="color: #ea580c;">ü¶ä LUKAVAC - Admin Panel</h1>
                    <p class="text-gray-600 mt-2">Kontrolni centar kviza</p>
                </div>
                <div class="flex gap-3">
                    <a href="index.html" class="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">‚Üê Nazad</a>
                    <button onclick="toggleSettings()" class="px-4 py-2 btn-primary text-white rounded-lg">
                        ‚öôÔ∏è Postavke
                    </button>
                </div>
            </div>
        </div>

        <!-- Quick Stats -->
        <div class="grid grid-cols-4 gap-4 mb-6">
            <div class="card p-4">
                <p class="text-gray-600 text-sm">Status</p>
                <p class="text-2xl font-bold" style="color: #ea580c;" id="gameStatus">ƒåekanje</p>
            </div>
            <div class="card p-4">
                <p class="text-gray-600 text-sm">Igraƒçi</p>
                <p class="text-2xl font-bold" style="color: #ea580c;"><span id="playerCount">0</span>/<span id="maxPlayers">8</span></p>
            </div>
            <div class="card p-4">
                <p class="text-gray-600 text-sm">Krug / Pitanje</p>
                <p class="text-2xl font-bold" style="color: #ea580c;"><span id="currentRound">1</span>/<span id="currentQuestion">0</span></p>
            </div>
            <div class="card p-4">
                <p class="text-gray-600 text-sm">Timer</p>
                <p class="text-2xl font-bold" style="color: #ea580c;" id="timerDisplay">--</p>
            </div>
        </div>

        <!-- Game Controls -->
        <div class="card p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4" style="color: #ea580c;">Kontrole Igre</h2>
            <div class="flex flex-wrap gap-3">
                <button onclick="startGame()" class="px-6 py-3 btn-primary text-white rounded-lg font-bold">
                    ‚ñ∂Ô∏è POKRENI KVIZ (AUTO MODE)
                </button>
                <button onclick="pauseGame()" class="px-6 py-3 bg-orange-600 hover:bg-orange-700 text-white rounded-lg font-bold">
                    ‚è∏Ô∏è Pauza
                </button>
                <button onclick="resumeGame()" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-bold">
                    ‚ñ∂Ô∏è Nastavi
                </button>
                <button onclick="nextQuestion()" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg font-bold">
                    ‚è≠Ô∏è Skip na Sljedeƒáe Pitanje
                </button>
                <button onclick="nextRound()" class="px-6 py-3 bg-pink-600 hover:bg-pink-700 text-white rounded-lg font-bold">
                    üîÑ Skip na Sljedeƒái Krug
                </button>
                <button onclick="resetPlayers()" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg font-bold">
                    üë• Reset Igraƒça
                </button>
                <button onclick="resetGame()" class="px-6 py-3 bg-red-800 hover:bg-red-900 text-white rounded-lg font-bold">
                    üóëÔ∏è Reset Kviza
                </button>
                <button onclick="exportData()" class="px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-bold">
                    üì• Export CSV
                </button>
            </div>
        </div>

        <!-- Player Management -->
        <div class="card p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4" style="color: #ea580c;">üë• Upravljanje Igraƒçima</h2>
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead>
                        <tr class="border-b-2 border-orange-200">
                            <th class="text-left p-2">Ime</th>
                            <th class="text-center p-2">Bodovi</th>
                            <th class="text-center p-2">Rang</th>
                            <th class="text-center p-2">? Lukavac</th>
                            <th class="text-center p-2">! Trouble</th>
                            <th class="text-center p-2">Ocjena</th>
                            <th class="text-center p-2">Akcije</th>
                        </tr>
                    </thead>
                    <tbody id="playersManagementList">
                        <tr>
                            <td colspan="7" class="text-center p-4 text-gray-500">Nema igraƒça</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="grid grid-cols-2 gap-6">
            <!-- Leaderboard -->
            <div class="card p-6">
                <h2 class="text-2xl font-bold mb-4" style="color: #ea580c;">üèÜ Poredak</h2>
                <div id="leaderboard" class="space-y-2">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <!-- Current Answers -->
            <div class="card p-6">
                <h2 class="text-2xl font-bold mb-4" style="color: #ea580c;">üìä Trenutni Odgovori</h2>
                <div id="currentAnswers" class="space-y-2">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 overflow-y-auto">
        <div class="card p-8 max-w-4xl w-full max-h-screen overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold" style="color: #ea580c;">‚öôÔ∏è Postavke Kviza</h2>
                <button onclick="toggleSettings()" class="text-3xl hover:text-red-600">√ó</button>
            </div>

            <!-- Basic Settings -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-3" style="color: #ea580c;">Osnovne Postavke</h3>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-bold mb-2">Naziv Kviza</label>
                        <input type="text" id="quizName" value="LUKAVAC DANA" class="w-full p-2 border-2 rounded-lg">
                    </div>
                    <div>
                        <label class="block text-sm font-bold mb-2">≈†ifra za Ulaz</label>
                        <input type="text" id="quizPassword" value="1234" class="w-full p-2 border-2 rounded-lg">
                    </div>
                    <div>
                        <label class="block text-sm font-bold mb-2">Min. Broj Igraƒça</label>
                        <input type="number" id="minPlayers" value="2" min="2" max="999" class="w-full p-2 border-2 rounded-lg">
                    </div>
                    <div>
                        <label class="block text-sm font-bold mb-2">Max. Broj Igraƒça</label>
                        <input type="number" id="maxPlayersInput" value="8" min="2" max="999" class="w-full p-2 border-2 rounded-lg">
                    </div>
                    <div>
                        <label class="block text-sm font-bold mb-2">Broj Krugova</label>
                        <input type="number" id="numRounds" value="6" min="1" max="99" onchange="generateRoundSettings()" class="w-full p-2 border-2 rounded-lg">
                    </div>
                </div>
            </div>

            <!-- Global Pause Mode Toggle -->
            <div class="mb-4">
                <div class="card p-4 flex items-center justify-between">
                    <div>
                        <label class="text-lg font-bold" style="color: #ea580c;">‚è∏Ô∏è Globalna Postavka Pauze</label>
                        <p class="text-sm text-gray-600 mt-1">Primijeni na sve krugove</p>
                    </div>
                    <label class="flex items-center gap-3 cursor-pointer">
                        <span class="text-sm font-bold">Ruƒçno</span>
                        <div class="relative">
                            <input type="checkbox" id="globalPauseAuto" onchange="setAllPauseModes(this.checked)" class="sr-only peer">
                            <div class="w-14 h-7 bg-gray-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-orange-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-orange-600"></div>
                        </div>
                        <span class="text-sm font-bold">Auto</span>
                    </label>
                </div>
            </div>

            <!-- Early Continue Toggle -->
            <div class="mb-4">
                <div class="card p-4">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <label class="text-lg font-bold" style="color: #ea580c;">‚ö° Automatski Nastavi Kad Svi Odgovore</label>
                            <p class="text-sm text-gray-600 mt-1">Preskaƒçe ƒçekanje na timer kada svi igraƒçi odgovore</p>
                        </div>
                        <label class="flex items-center gap-3 cursor-pointer">
                            <span class="text-sm font-bold">OFF</span>
                            <div class="relative">
                                <input type="checkbox" id="earlyContinue" class="sr-only peer" checked>
                                <div class="w-14 h-7 bg-gray-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-green-600"></div>
                            </div>
                            <span class="text-sm font-bold">ON</span>
                        </label>
                    </div>
                    <div class="text-xs text-gray-600 mt-2 p-3 bg-gray-50 rounded">
                        <strong>Faza 1:</strong> Kada svi igraƒçi odgovore ‚Üí automatski ide na Fazu 2 (Lukavac)<br>
                        <strong>Faza 2:</strong> Kada svi koji su stisnuli ? odgovore ‚Üí automatski ide na Prikaz Odgovora<br>
                        <em>Timer i dalje odbrojav–∞, ali se ne ƒçeka do kraja.</em>
                    </div>
                </div>
            </div>

            <!-- Round Settings -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-3" style="color: #ea580c;">Postavke po Krugovima</h3>
                <div id="roundSettings">
                    <!-- Dynamically generated -->
                </div>
            </div>

            <!-- Questions Management -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-3" style="color: #ea580c;">üìù Upravljanje Pitanjima</h3>
                
                <!-- Questions List -->
                <div class="mb-4 p-4 rounded-lg max-h-96 overflow-y-auto" style="background: #f5e6d3;">
                    <h4 class="font-bold mb-2">Dodana pitanja (<span id="questionCount2">0</span>):</h4>
                    <div id="questionsList" class="space-y-2 text-sm">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-bold mb-2">Uƒçitaj CSV File</label>
                    <input type="file" id="csvFile" accept=".csv" onchange="loadCSV()" class="w-full p-2 border-2 rounded-lg">
                    <p class="text-xs text-gray-600 mt-1">Format: round,text,answer_a,answer_b,answer_c,answer_d,correct</p>
                </div>
                
                <!-- Manual Add Question -->
                <div id="addQuestionForm" class="hidden mt-4 p-4 rounded-lg" style="background: #f5e6d3;">
                    <h4 class="font-bold mb-3">Novo Pitanje:</h4>
                    <input type="text" id="newQuestionText" placeholder="Tekst pitanja..." class="w-full p-2 border-2 rounded-lg mb-2">
                    <input type="text" id="newAnswerA" placeholder="Odgovor A" class="w-full p-2 border-2 rounded-lg mb-2">
                    <input type="text" id="newAnswerB" placeholder="Odgovor B" class="w-full p-2 border-2 rounded-lg mb-2">
                    <input type="text" id="newAnswerC" placeholder="Odgovor C" class="w-full p-2 border-2 rounded-lg mb-2">
                    <input type="text" id="newAnswerD" placeholder="Odgovor D" class="w-full p-2 border-2 rounded-lg mb-2">
                    <div class="flex gap-2">
                        <select id="newQuestionRound" class="p-2 border-2 rounded-lg">
                            <option value="1">Krug 1</option>
                            <option value="2">Krug 2</option>
                            <option value="3">Krug 3</option>
                            <option value="4">Krug 4</option>
                            <option value="5">Krug 5</option>
                            <option value="6">Krug 6</option>
                        </select>
                        <select id="newQuestionCorrect" class="p-2 border-2 rounded-lg">
                            <option value="0">A - Toƒçan</option>
                            <option value="1">B - Toƒçan</option>
                            <option value="2">C - Toƒçan</option>
                            <option value="3">D - Toƒçan</option>
                        </select>
                        <button onclick="addQuestionManually()" class="px-4 py-2 bg-green-600 text-white rounded-lg">Dodaj</button>
                        <button onclick="toggleAddQuestion()" class="px-4 py-2 bg-gray-400 text-white rounded-lg">Odustani</button>
                    </div>
                </div>
                
                <button onclick="toggleAddQuestion()" id="btnShowAddQuestion" class="px-4 py-2 btn-primary text-white rounded-lg">
                    ‚ûï Dodaj Pitanje Ruƒçno
                </button>
            </div>

            <div class="flex gap-3">
                <button onclick="saveSettings()" class="flex-1 py-3 btn-primary text-white rounded-lg font-bold">
                    üíæ Spremi Postavke
                </button>
                <button onclick="toggleSettings()" class="flex-1 py-3 bg-gray-300 hover:bg-gray-400 rounded-lg font-bold">
                    Odustani
                </button>
            </div>
        </div>
    </div>

    <script src="firebase-config.js"></script>
    <script>
        let gameState = null;
        let players = {};
        let settings = {};
        let questions = [];
        let answers = {};
        let timerInterval = null;
        let serverTimeOffset = 0;
        let earlyContinueTriggered = false; // Prevent multiple triggers

        // Get server time offset for sync
        database.ref('.info/serverTimeOffset').on('value', snap => {
            serverTimeOffset = snap.val() || 0;
            console.log('‚è∞ Admin server time offset:', serverTimeOffset);
        });

        // Initialize default settings
        const defaultSettings = {
            quizName: "LUKAVAC DANA",
            password: "1234",
            minPlayers: 2,
            maxPlayers: 8,
            numRounds: 6,
            earlyContinue: true,
            rounds: [
                { questions: 10, values: [10, 5, 0, -5, -10], elimination: 2, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" },
                { questions: 10, values: [20, 10, 0, -10, -20], elimination: 1, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" },
                { questions: 10, values: [30, 15, 0, -15, -30], elimination: 1, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" },
                { questions: 10, values: [40, 20, 0, -20, -40], elimination: 1, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" },
                { questions: 10, values: [50, 25, 0, -25, -50], elimination: 1, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" },
                { questions: 10, values: [100, 50, 0, -50, -100], elimination: 1, time1: 20, time2: 5, timeAnswer: 5, timePause: 45, pauseRound: "auto" }
            ]
        };

        // Firebase listeners
        database.ref('settings').on('value', snap => {
            settings = snap.val() || defaultSettings;
            updateSettingsUI();
        });

        database.ref('gameState').on('value', snap => {
            gameState = snap.val();
            updateUI();
        });

        database.ref('players').on('value', snap => {
            players = snap.val() || {};
            updateLeaderboard();
            updatePlayersManagement();
        });

        database.ref('questions').on('value', snap => {
            questions = snap.val() || [];
            updateQuestionsList();
        });

        database.ref('answers').on('value', snap => {
            answers = snap.val() || {};
            updateCurrentAnswers();
            checkEarlyContinue(); // Check if all answered
        });

        function checkEarlyContinue() {
            if (!settings.earlyContinue) return; // Feature disabled
            if (!gameState || !gameState.isActive) return;
            if (earlyContinueTriggered) return; // Already triggered for this question
            
            const phase = gameState.phase;
            if (phase !== 'answering' && phase !== 'lukavac') return;
            
            const activePlayers = Object.keys(players);
            const answeredPlayers = Object.keys(answers);
            
            console.log('=== EARLY CONTINUE CHECK ===');
            console.log('Phase:', phase);
            console.log('Active players:', activePlayers.length);
            console.log('Answered players:', answeredPlayers.length);
            console.log('Already triggered:', earlyContinueTriggered);
            
            if (phase === 'answering') {
                // FAZA 1: Svi aktivni igraƒçi su odgovorili?
                const allAnswered = activePlayers.every(pid => answers[pid] !== undefined);
                
                if (allAnswered && activePlayers.length > 0) {
                    console.log('‚úÖ All players answered in Phase 1!');
                    earlyContinueTriggered = true; // Mark as triggered
                    
                    // Check if anyone chose lukavac (?)
                    const hasLukavac = Object.values(answers).some(a => a.type === 'lukavac');
                    
                    if (!hasLukavac && settings.earlyContinue) {
                        // NO LUKAVAC - Skip to answer immediately
                        console.log('‚è≠Ô∏è No lukavac players - skipping to answer');
                        
                        // Show notification in admin
                        const notification = document.createElement('div');
                        notification.className = 'fixed top-20 right-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 font-bold';
                        notification.textContent = 'Nema lukavaca';
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 3000);
                        
                        // Wait 1 second then show answer directly
                        setTimeout(() => {
                            if (gameState.phase === 'answering') {
                                showAnswer();
                            }
                        }, 1000);
                    } else {
                        // HAS LUKAVAC - Normal transition to phase 2
                        console.log('ü¶ä Has lukavac players - moving to phase 2');
                        
                        // Show notification in admin
                        const notification = document.createElement('div');
                        notification.className = 'fixed top-20 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 font-bold';
                        notification.textContent = '‚úÖ Svi su odgovorili! Prelazak na Fazu 2...';
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 3000);
                        
                        // Wait 1 second then move to lukavac
                        setTimeout(() => {
                            if (gameState.phase === 'answering') { // Still in same phase
                                showLukavacPhase();
                            }
                        }, 1000);
                    }
                }
            } else if (phase === 'lukavac') {
                // FAZA 2: Svi koji su stisnuli ? su odgovorili?
                const pendingPlayers = activePlayers.filter(pid => {
                    const answer = answers[pid];
                    return answer && answer.pending === true;
                });
                
                const allPendingAnswered = pendingPlayers.every(pid => {
                    const answer = answers[pid];
                    return answer && answer.pending === false;
                });
                
                console.log('Pending players:', pendingPlayers.length);
                console.log('All pending answered:', allPendingAnswered);
                
                if (allPendingAnswered && pendingPlayers.length > 0) {
                    console.log('‚úÖ All lukavac players answered! Moving to show answer...');
                    earlyContinueTriggered = true; // Mark as triggered
                    
                    // Show notification in admin
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-20 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 font-bold';
                    notification.textContent = 'Svi su odgovorili';
                    document.body.appendChild(notification);
                    setTimeout(() => notification.remove(), 3000);
                    
                    // Wait 1 second then show answer
                    setTimeout(() => {
                        if (gameState.phase === 'lukavac') { // Still in same phase
                            showAnswer();
                        }
                    }, 1000);
                }
            }
        }

        function updateUI() {
            if (!gameState) return;
            
            document.getElementById('gameStatus').textContent = 
                gameState.phase === 'waiting' ? 'ƒåekanje' :
                gameState.phase === 'answering' ? 'Odgovaranje' :
                gameState.phase === 'lukavac' ? 'Lukavac Faza' :
                gameState.phase === 'showAnswer' ? 'Prikaz Odgovora' : 'Pauza';
            
            document.getElementById('currentRound').textContent = gameState.currentRound || 1;
            document.getElementById('currentQuestion').textContent = (gameState.currentQuestion || 0) + 1;
            document.getElementById('playerCount').textContent = Object.keys(players).length;
            document.getElementById('maxPlayers').textContent = settings.maxPlayers || 8;

            // Timer
            if (gameState.timerEnd) {
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(updateTimer, 100);
            }
        }

        function updateTimer() {
            if (!gameState || !gameState.timerEnd) {
                document.getElementById('timerDisplay').textContent = '--';
                return;
            }
            const serverNow = Date.now() + serverTimeOffset;
            const timeLeft = Math.max(0, Math.ceil((gameState.timerEnd - serverNow) / 1000));
            document.getElementById('timerDisplay').textContent = timeLeft + 's';
            if (timeLeft === 0) clearInterval(timerInterval);
        }

        function updateLeaderboard() {
            const sorted = Object.entries(players)
                .map(([id, data]) => ({ id, ...data }))
                .sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    if (b.lukavacCount !== a.lukavacCount) return b.lukavacCount - a.lukavacCount;
                    if (b.exclamationCount !== a.exclamationCount) return b.exclamationCount - a.exclamationCount;
                    return a.totalTime - b.totalTime;
                });

            const html = sorted.map((player, idx) => {
                const timeInSeconds = Math.floor((player.totalTime || 0) / 1000);
                return `
                <div class="flex justify-between items-center p-3 rounded-lg" style="background: #f5e6d3;">
                    <div class="flex items-center gap-3">
                        <span class="font-bold text-xl" style="color: #ea580c;">${idx + 1}.</span>
                        <span class="font-bold">${player.name}</span>
                    </div>
                    <div class="flex items-center gap-4">
                        <span class="font-bold" style="color: #ea580c;">${player.score || 0}‚Ç¨</span>
                        <span class="text-sm text-gray-600">${player.lukavacCount || 0}?</span>
                        <span class="text-sm text-gray-600">${player.exclamationCount || 0}!</span>
                        <span class="text-xs text-gray-600">‚è±Ô∏è${timeInSeconds}s</span>
                    </div>
                </div>
            `}).join('');
            document.getElementById('leaderboard').innerHTML = html || '<p class="text-gray-500">Nema igraƒça</p>';
        }

        function updateCurrentAnswers() {
            const currentPhase = gameState?.phase || 'waiting';
            
            const html = Object.entries(answers).map(([pid, data]) => {
                const player = players[pid];
                if (!player) return '';
                
                // U answering fazi - ako je pending (ƒçeka lukavac fazu)
                if (currentPhase === 'answering' && data.pending && data.answer === -1) {
                    return `
                        <div class="flex justify-between items-center p-2 rounded" style="background: #a855f7;">
                            <span class="font-bold text-white">${player.name}</span>
                            <span class="font-bold text-white text-xl">?</span>
                        </div>
                    `;
                }
                
                // U lukavac/showAnswer fazi - prika≈æi A? B? C? D? ako je odgovorio
                const answerLabel = data.answer >= 0 ? String.fromCharCode(65 + data.answer) : '?';
                const typeSymbol = data.type === 'exclamation' ? '!' : data.type === 'period' ? '.' : '?';
                const bgColor = data.type === 'exclamation' ? '#ef4444' : data.type === 'period' ? '#3b82f6' : '#a855f7';
                
                // Ako je lukavac i veƒá odgovorio, prika≈æi A? B? C? D?
                const displayText = data.type === 'lukavac' && data.answer >= 0 ? 
                    `${answerLabel}${typeSymbol}` : 
                    data.pending ? '?' : `${answerLabel}${typeSymbol}`;
                
                return `
                    <div class="flex justify-between items-center p-2 rounded" style="background: ${bgColor};">
                        <span class="font-bold text-white">${player.name}</span>
                        <span class="font-bold text-white">${displayText}</span>
                    </div>
                `;
            }).join('');
            document.getElementById('currentAnswers').innerHTML = html || '<p class="text-gray-500">Nema odgovora</p>';
        }

        function toggleSettings() {
            console.log('=== TOGGLE SETTINGS CLICKED ===');
            try {
                const modal = document.getElementById('settingsModal');
                console.log('Modal element:', modal);
                modal.classList.toggle('hidden');
                if (!modal.classList.contains('hidden')) {
                    console.log('Generating round settings...');
                    generateRoundSettings();
                    console.log('Round settings generated');
                }
            } catch (error) {
                console.error('ERROR in toggleSettings:', error);
                alert('Gre≈°ka pri otvaranju postavki: ' + error.message);
            }
        }

        function setAllPauseModes(isAuto) {
            const numRounds = parseInt(document.getElementById('numRounds').value) || 6;
            for (let i = 0; i < numRounds; i++) {
                const checkbox = document.getElementById(`round${i}_pauseAuto`);
                if (checkbox) {
                    checkbox.checked = isAuto;
                }
            }
        }

        function generateRoundSettings() {
            console.log('=== GENERATE ROUND SETTINGS START ===');
            try {
                const numRounds = parseInt(document.getElementById('numRounds').value);
                console.log('Number of rounds:', numRounds);
                const container = document.getElementById('roundSettings');
                console.log('Container:', container);
                let html = '';

            for (let i = 0; i < numRounds; i++) {
                console.log('Generating round', i + 1);
                const round = settings.rounds?.[i] || defaultSettings.rounds[i] || defaultSettings.rounds[0];
                const pauseMode = round.pauseRound || 'auto'; // Default to auto
                console.log('Round', i + 1, 'pauseMode:', pauseMode);
                html += `
                    <div class="mb-4 p-4 rounded-lg" style="background: #f5e6d3;">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold" style="color: #ea580c;">${i + 1}. KRUG</h4>
                            <span class="text-xs px-2 py-1 rounded ${pauseMode === 'auto' ? 'bg-green-500' : 'bg-orange-500'} text-white font-bold">
                                ${pauseMode === 'auto' ? '‚ö° AUTO' : '‚úã RUƒåNO'}
                            </span>
                        </div>
                        <div class="grid grid-cols-3 gap-3">
                            <div>
                                <label class="text-xs">Broj pitanja</label>
                                <input type="number" id="round${i}_questions" value="${round.questions}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Ostaje igraƒça</label>
                                <input type="number" id="round${i}_remaining" value="${round.remainingPlayers || round.elimination || 0}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Vrijeme ! i . (s)</label>
                                <input type="number" id="round${i}_time1" value="${round.time1}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Vrijeme ? (s)</label>
                                <input type="number" id="round${i}_time2" value="${round.time2}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Prikaz odg. (s)</label>
                                <input type="number" id="round${i}_timeAnswer" value="${round.timeAnswer}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Pauza (s)</label>
                                <input type="number" id="round${i}_timePause" value="${round.timePause}" class="w-full p-1 border rounded">
                            </div>
                            <div>
                                <label class="text-xs">Pauza Mode</label>
                                <label class="flex items-center gap-2 p-2 border rounded cursor-pointer hover:bg-gray-50">
                                    <input type="checkbox" id="round${i}_pauseAuto" ${pauseMode === 'auto' ? 'checked' : ''} class="w-4 h-4">
                                    <span class="text-xs">Auto nastavi</span>
                                </label>
                            </div>
                        </div>
                        <div class="mt-2">
                            <label class="text-xs">Vrijednosti (!, ., netoƒçno !, netoƒçno ?)</label>
                            <div class="grid grid-cols-5 gap-2">
                                <input type="number" id="round${i}_val0" value="${round.values[0]}" placeholder="+!" class="w-full p-1 border rounded">
                                <input type="number" id="round${i}_val1" value="${round.values[1]}" placeholder="+." class="w-full p-1 border rounded">
                                <input type="number" id="round${i}_val2" value="${round.values[2]}" placeholder="0" class="w-full p-1 border rounded">
                                <input type="number" id="round${i}_val3" value="${round.values[3]}" placeholder="-?" class="w-full p-1 border rounded">
                                <input type="number" id="round${i}_val4" value="${round.values[4]}" placeholder="-!" class="w-full p-1 border rounded">
                            </div>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
            console.log('=== GENERATE ROUND SETTINGS COMPLETE ===');
        } catch (error) {
            console.error('ERROR in generateRoundSettings:', error);
            alert('Gre≈°ka pri generiranju postavki: ' + error.message);
        }
        }

        function updateSettingsUI() {
            document.getElementById('quizName').value = settings.quizName || "LUKAVAC DANA";
            document.getElementById('quizPassword').value = settings.password || "1234";
            document.getElementById('minPlayers').value = settings.minPlayers || 2;
            document.getElementById('maxPlayersInput').value = settings.maxPlayers || 8;
            document.getElementById('numRounds').value = settings.numRounds || 6;
            document.getElementById('earlyContinue').checked = settings.earlyContinue !== false; // Default true
        }

        function saveSettings() {
            const numRounds = parseInt(document.getElementById('numRounds').value);
            const rounds = [];

            for (let i = 0; i < numRounds; i++) {
                const pauseAuto = document.getElementById(`round${i}_pauseAuto`).checked;
                rounds.push({
                    questions: parseInt(document.getElementById(`round${i}_questions`).value),
                    remainingPlayers: parseInt(document.getElementById(`round${i}_remaining`).value),
                    time1: parseInt(document.getElementById(`round${i}_time1`).value),
                    time2: parseInt(document.getElementById(`round${i}_time2`).value),
                    timeAnswer: parseInt(document.getElementById(`round${i}_timeAnswer`).value),
                    timePause: parseInt(document.getElementById(`round${i}_timePause`).value),
                    pauseRound: pauseAuto ? "auto" : "manual",
                    values: [
                        parseInt(document.getElementById(`round${i}_val0`).value),
                        parseInt(document.getElementById(`round${i}_val1`).value),
                        parseInt(document.getElementById(`round${i}_val2`).value),
                        parseInt(document.getElementById(`round${i}_val3`).value),
                        parseInt(document.getElementById(`round${i}_val4`).value)
                    ]
                });
            }

            const newSettings = {
                quizName: document.getElementById('quizName').value,
                password: document.getElementById('quizPassword').value,
                minPlayers: parseInt(document.getElementById('minPlayers').value),
                maxPlayers: parseInt(document.getElementById('maxPlayersInput').value),
                numRounds: numRounds,
                rounds: rounds,
                earlyContinue: document.getElementById('earlyContinue').checked
            };

            database.ref('settings').set(newSettings).then(() => {
                alert('‚úÖ Postavke spremljene!');
                toggleSettings();
            });
        }

        function startGame() {
            if (Object.keys(players).length < (settings.minPlayers || 2)) {
                alert(`Potrebno je minimalno ${settings.minPlayers || 2} igraƒça!`);
                return;
            }
            database.ref('gameState').set({
                phase: 'waiting',
                currentRound: 1,
                currentQuestion: 0,
                isActive: true,
                autoMode: true,
                timerEnd: null
            });
            
            // AUTO: Pokreni prvo pitanje nakon 3s
            setTimeout(() => {
                database.ref('gameState').once('value').then(snap => {
                    const state = snap.val();
                    if (state.autoMode) startQuestion();
                });
            }, 3000);
        }

        function pauseGame() {
            database.ref('gameState').update({ 
                autoMode: false,
                phase: 'paused', 
                timerEnd: null 
            });
        }

        function resumeGame() {
            database.ref('gameState').update({ 
                autoMode: true,
                phase: 'waiting'
            });
            setTimeout(() => {
                if (gameState.autoMode) startQuestion();
            }, 2000);
        }

        function startQuestion() {
            earlyContinueTriggered = false; // Reset flag for new question
            const round = settings.rounds[gameState.currentRound - 1];
            
            // Koristi server timestamp za sinkronizaciju
            database.ref('.info/serverTimeOffset').once('value').then(offsetSnap => {
                const offset = offsetSnap.val() || 0;
                const serverTime = Date.now() + offset;
                
                database.ref('gameState').update({
                    phase: 'answering',
                    timerEnd: serverTime + (round.time1 * 1000),
                    autoMode: true
                });
                database.ref('answers').set({});
                
                // AUTO: Nakon 20s -> lukavac faza
                setTimeout(() => {
                    database.ref('gameState').once('value').then(snap => {
                        const state = snap.val();
                        if (state && state.autoMode) showLukavacPhase();
                    });
                }, round.time1 * 1000);
            });
        }

        function showLukavacPhase() {
            const round = settings.rounds[(gameState.currentRound || 1) - 1];
            if (!round) return;
            
            console.log('üëÅÔ∏è Starting Lukavac phase');
            
            // Auto-assign ? to players who didn't answer - SA RELATIVNIM VREMENOM
            database.ref('players').once('value').then(playersSnap => {
                const allPlayers = playersSnap.val() || {};
                database.ref('answers').once('value').then(answersSnap => {
                    const answers = answersSnap.val() || {};
                    
                    // Za svakog igraƒça koji nije odgovorio, dodaj "pending lukavac"
                    Object.keys(allPlayers).forEach(pid => {
                        if (!answers[pid]) {
                            console.log('‚ö†Ô∏è Player', allPlayers[pid].name, 'didnt answer - auto lukavac');
                            database.ref(`answers/${pid}`).set({
                                answer: -1, // Placeholder - nije jo≈° odgovorio
                                type: 'lukavac',
                                pending: true,
                                timestamp: round.time1 * 1000 // Potro≈°io je svih 20s
                            });
                        }
                    });
                });
            });
            
            // Koristi server timestamp
            database.ref('.info/serverTimeOffset').once('value').then(offsetSnap => {
                const offset = offsetSnap.val() || 0;
                const serverTime = Date.now() + offset;
                
                database.ref('gameState').update({
                    phase: 'lukavac',
                    timerEnd: serverTime + (round.time2 * 1000)
                });
                
                // AUTO: Nakon 5s -> prikaz toƒçnog odgovora
                setTimeout(() => {
                    database.ref('gameState').once('value').then(snap => {
                        const state = snap.val();
                        if (state && state.autoMode && state.phase === 'lukavac') {
                            console.log('‚úÖ Auto showing correct answer');
                            
                            // Svi koji jo≈° nisu odgovorili dobivaju random netoƒçan odgovor
                            autoAnswerPendingPlayers();
                            
                            showCorrectAnswer();
                        }
                    });
                }, round.time2 * 1000);
            });
        }

        function autoAnswerPendingPlayers() {
            database.ref('answers').once('value').then(snap => {
                const answers = snap.val() || {};
                const currentQ = questions[(gameState.currentQuestion || 0)];
                if (!currentQ) return;
                
                Object.entries(answers).forEach(([pid, data]) => {
                    if (data.pending && data.answer === -1) {
                        // Daj prvi netoƒçan odgovor
                        let wrongAnswer = 0;
                        while (wrongAnswer === currentQ.correct && wrongAnswer < 4) {
                            wrongAnswer++;
                        }
                        if (wrongAnswer >= 4) wrongAnswer = (currentQ.correct + 1) % 4;
                        
                        console.log('‚ö†Ô∏è Auto-answering for player', pid, 'with wrong answer', wrongAnswer);
                        
                        database.ref(`answers/${pid}`).update({
                            answer: wrongAnswer,
                            pending: false
                        });
                    }
                });
            });
        }

        function showCorrectAnswer() {
            const round = settings.rounds[(gameState.currentRound || 1) - 1];
            if (!round) return;
            
            console.log('üìä Showing correct answer');
            
            // Koristi server timestamp
            database.ref('.info/serverTimeOffset').once('value').then(offsetSnap => {
                const offset = offsetSnap.val() || 0;
                const serverTime = Date.now() + offset;
                
                database.ref('gameState').update({
                    phase: 'showAnswer',
                    timerEnd: serverTime + (round.timeAnswer * 1000)
                });
                calculateScores();
                
                // AUTO: Nakon 5s -> pauza (leaderboard)
                setTimeout(() => {
                    database.ref('gameState').once('value').then(snap => {
                        const state = snap.val();
                        if (state && state.autoMode && state.phase === 'showAnswer') {
                            console.log('‚è∏Ô∏è Auto starting pause');
                            startPause();
                        }
                    });
                }, round.timeAnswer * 1000);
            });
        }

        function startPause() {
            const round = settings.rounds[(gameState.currentRound || 1) - 1];
            if (!round) return;
            
            console.log('‚è∏Ô∏è Starting pause');
            
            // Koristi server timestamp
            database.ref('.info/serverTimeOffset').once('value').then(offsetSnap => {
                const offset = offsetSnap.val() || 0;
                const serverTime = Date.now() + offset;
                
                const timerEnd = round.pauseRound === 'manual' ? null : serverTime + (round.timePause * 1000);
                
                database.ref('gameState').update({
                    phase: 'pause',
                    timerEnd: timerEnd
                });
                
                // AUTO: Nakon pauze -> sljedeƒáe pitanje (ako nije manual)
                if (round.pauseRound !== 'manual') {
                    setTimeout(() => {
                        database.ref('gameState').once('value').then(snap => {
                            const state = snap.val();
                            if (state && state.autoMode && state.phase === 'pause') {
                                console.log('‚è≠Ô∏è Auto next question');
                                nextQuestion();
                            }
                        });
                    }, round.timePause * 1000);
                }
            });
        }

        function calculateScores() {
            const currentQ = questions[gameState.currentQuestion];
            const round = settings.rounds[gameState.currentRound - 1];
            
            Object.entries(answers).forEach(([pid, data]) => {
                const correct = currentQ.correct === data.answer;
                let points = 0;
                
                if (data.type === 'exclamation') {
                    points = correct ? round.values[0] : round.values[4];
                } else if (data.type === 'period') {
                    points = correct ? round.values[1] : round.values[2];
                } else if (data.type === 'lukavac') {
                    points = correct ? round.values[1] : round.values[3];
                }
                
                const player = players[pid];
                database.ref(`players/${pid}`).update({
                    score: (player.score || 0) + points,
                    lukavacCount: (player.lukavacCount || 0) + (data.type === 'lukavac' ? 1 : 0),
                    exclamationCount: (player.exclamationCount || 0) + (data.type === 'exclamation' ? 1 : 0),
                    totalTime: (player.totalTime || 0) + (data.timestamp || 0)
                });
            });
        }

        function nextQuestion() {
            const round = settings.rounds[gameState.currentRound - 1];
            const nextQ = (gameState.currentQuestion || 0) + 1;
            
            console.log('üìå Next question:', nextQ, 'Round questions:', round.questions);
            
            // Provjera da li je kraj kruga
            if (nextQ >= round.questions) {
                console.log('üèÅ Kraj kruga!');
                database.ref('gameState').update({
                    phase: 'roundEnd',
                    timerEnd: null,
                    autoMode: false
                });
                return;
            }
            
            database.ref('gameState').update({
                currentQuestion: nextQ,
                phase: 'waiting',
                timerEnd: null,
                autoMode: true
            });
            database.ref('answers').set({});
            
            // AUTO: Pokreni sljedeƒáe pitanje nakon 2s
            setTimeout(() => {
                database.ref('gameState').once('value').then(snap => {
                    const state = snap.val();
                    if (state && state.autoMode) {
                        console.log('‚ñ∂Ô∏è Auto starting question:', nextQ);
                        startQuestion();
                    }
                });
            }, 2000);
        }

        function nextRound() {
            const nextR = gameState.currentRound + 1;
            
            // Provjera da li je kraj kviza
            if (nextR > settings.numRounds) {
                database.ref('gameState').update({
                    phase: 'gameEnd',
                    timerEnd: null
                });
                return;
            }
            
            database.ref('gameState').update({
                currentRound: nextR,
                currentQuestion: 0,
                phase: 'waiting',
                timerEnd: null
            });
            database.ref('answers').set({});
            
            // AUTO: Pokreni prvi pitanje novog kruga nakon 3s
            setTimeout(() => {
                if (gameState.autoMode) startQuestion();
            }, 3000);
        }

        function pauseGame() {
            database.ref('gameState').update({ 
                autoMode: false,
                phase: 'paused', 
                timerEnd: null 
            });
        }

        function resumeGame() {
            database.ref('gameState').update({ 
                autoMode: true,
                phase: 'waiting'
            });
            setTimeout(() => {
                database.ref('gameState').once('value').then(snap => {
                    const state = snap.val();
                    if (state && state.autoMode) startQuestion();
                });
            }, 2000);
        }

        function resetPlayers() {
            if (confirm('‚ùå RESET IGRAƒåA - Obrisat ƒáe se svi igraƒçi! Sigurno?')) {
                database.ref('players').set({}).then(() => {
                    alert('‚úÖ Svi igraƒçi obrisani!');
                });
            }
        }

        function resetGame() {
            if (confirm('‚ùå RESET KVIZA - Obrisat ƒáe se cijela igra, svi igraƒçi i odgovori! Sigurno?')) {
                database.ref('gameState').set({
                    phase: 'waiting',
                    currentRound: 1,
                    currentQuestion: 0,
                    isActive: false,
                    autoMode: false,
                    timerEnd: null
                });
                database.ref('players').set({});
                database.ref('answers').set({});
                alert('‚úÖ Kviz resetiran!');
            }
        }

        async function exportData() {
            console.log('üìä Starting comprehensive CSV export...');
            showNotification('Pripremam CSV izvje≈°taj...', 'info');
            
            try {
                // Fetch all data from Firebase
                const [playersSnap, questionsSnap, settingsSnap, gameStateSnap, historySnap] = await Promise.all([
                    database.ref('players').once('value'),
                    database.ref('questions').once('value'),
                    database.ref('settings').once('value'),
                    database.ref('gameState').once('value'),
                    database.ref('answerHistory').once('value')
                ]);
                
                const playersData = playersSnap.val() || {};
                const questionsData = questionsSnap.val() || [];
                const settingsData = settingsSnap.val() || {};
                const gameStateData = gameStateSnap.val() || {};
                const historyData = historySnap.val() || {};
                
                console.log('Data loaded:', {
                    players: Object.keys(playersData).length,
                    questions: questionsData.length,
                    history: Object.keys(historyData).length
                });
                
                // Build CSV
                let csv = '';
                const now = new Date();
                
                // ========== HEADER ==========
                csv += `LUKAVAC KVIZ - DETALJNI IZVJE≈†TAJ\n`;
                csv += `\n`;
                csv += `Naziv kviza:,${settingsData.quizName || 'N/A'}\n`;
                csv += `Datum izvje≈°taja:,${now.toLocaleDateString('hr-HR')}\n`;
                csv += `Vrijeme izvje≈°taja:,${now.toLocaleTimeString('hr-HR')}\n`;
                csv += `Ukupno igraƒça:,${Object.keys(playersData).length}\n`;
                csv += `Ukupno krugova:,${settingsData.rounds?.length || 0}\n`;
                csv += `Ukupno pitanja:,${questionsData.length}\n`;
                csv += `\n`;
                
                // ========== FINAL RANKINGS ==========
                csv += `KONAƒåNI POREDAK\n`;
                csv += `Rang,Ime Igraƒça,Zavr≈°ni Bodovi,Lukavac (?),Trouble (!),Vrijeme (s),Ocjena Admin\n`;
                
                const sortedPlayers = Object.entries(playersData)
                    .map(([id, data]) => ({ id, ...data }))
                    .sort((a, b) => {
                        if (b.score !== a.score) return b.score - a.score;
                        if ((b.lukavacCount || 0) !== (a.lukavacCount || 0)) return (b.lukavacCount || 0) - (a.lukavacCount || 0);
                        if ((b.exclamationCount || 0) !== (a.exclamationCount || 0)) return (b.exclamationCount || 0) - (a.exclamationCount || 0);
                        return (a.totalTime || 0) - (b.totalTime || 0);
                    });
                
                sortedPlayers.forEach((player, idx) => {
                    const timeInSeconds = Math.floor((player.totalTime || 0) / 1000);
                    csv += `${idx + 1},`;
                    csv += `"${escapeCSV(player.name || 'Unknown')}",`;
                    csv += `${player.score || 0},`;
                    csv += `${player.lukavacCount || 0},`;
                    csv += `${player.exclamationCount || 0},`;
                    csv += `${timeInSeconds},`;
                    csv += `${player.rating || '-'}\n`;
                });
                
                csv += `\n\n`;
                
                // ========== QUESTION-BY-QUESTION BREAKDOWN ==========
                csv += `DETALJAN PRIKAZ PO PITANJIMA\n`;
                csv += `Krug,Pitanje #,Tekst Pitanja,Odgovor A,Odgovor B,Odgovor C,Odgovor D,Toƒçan Odgovor,Ime Igraƒça,Tip (!/./?) ,Odabran Odgovor,Dobiveni Bodovi\n`;
                
                // Process each question
                let globalQuestionIndex = 0;
                for (let roundIdx = 0; roundIdx < (settingsData.rounds?.length || 0); roundIdx++) {
                    const round = settingsData.rounds[roundIdx];
                    const questionsInRound = round.questions || 10;
                    
                    for (let qInRound = 0; qInRound < questionsInRound && globalQuestionIndex < questionsData.length; qInRound++, globalQuestionIndex++) {
                        const question = questionsData[globalQuestionIndex];
                        const correctAnswerLetter = String.fromCharCode(65 + question.correct); // A, B, C, D
                        const correctAnswerText = question.answers[question.correct];
                        
                        // For each player, find their answer to THIS question
                        sortedPlayers.forEach(player => {
                            const historyKey = `R${roundIdx + 1}Q${qInRound + 1}`;
                            const playerHistory = historyData[player.id];
                            const answerData = playerHistory ? playerHistory[historyKey] : null;
                            
                            let answerType = '-';
                            let selectedAnswer = 'Nije odgovorio';
                            let points = 0;
                            
                            if (answerData) {
                                // Determine final answer (after lukavac phase if applicable)
                                const finalAnswerIndex = answerData.finalAnswer !== undefined ? answerData.finalAnswer : answerData.answer;
                                const finalType = answerData.finalType || answerData.type;
                                
                                // Type symbol
                                answerType = finalType === 'exclamation' ? '!' : 
                                            finalType === 'period' ? '.' : 
                                            finalType === 'lukavac' ? '?' : '-';
                                
                                // Selected answer text
                                if (finalAnswerIndex >= 0 && finalAnswerIndex < question.answers.length) {
                                    const answerLetter = String.fromCharCode(65 + finalAnswerIndex);
                                    selectedAnswer = `${answerLetter}. ${question.answers[finalAnswerIndex]}`;
                                }
                                
                                // Calculate points
                                const isCorrect = finalAnswerIndex === question.correct;
                                if (isCorrect) {
                                    if (finalType === 'exclamation') points = round.values[0]; // ! correct
                                    else if (finalType === 'period') points = round.values[1]; // . correct
                                    else if (finalType === 'lukavac') points = round.values[1]; // ? correct
                                } else {
                                    if (finalType === 'exclamation') points = round.values[4]; // ! wrong (negative)
                                    else if (finalType === 'period') points = 0; // . wrong
                                    else if (finalType === 'lukavac') points = round.values[3]; // ? wrong
                                }
                            }
                            
                            // Write CSV row
                            csv += `${roundIdx + 1},`;
                            csv += `${qInRound + 1},`;
                            csv += `"${escapeCSV(question.text)}",`;
                            csv += `"${escapeCSV(question.answers[0] || '')}",`;
                            csv += `"${escapeCSV(question.answers[1] || '')}",`;
                            csv += `"${escapeCSV(question.answers[2] || '')}",`;
                            csv += `"${escapeCSV(question.answers[3] || '')}",`;
                            csv += `"${correctAnswerLetter}. ${escapeCSV(correctAnswerText)}",`;
                            csv += `"${escapeCSV(player.name || 'Unknown')}",`;
                            csv += `${answerType},`;
                            csv += `"${escapeCSV(selectedAnswer)}",`;
                            csv += `${points >= 0 ? '+' : ''}${points}\n`;
                        });
                    }
                }
                
                csv += `\n\n`;
                
                // ========== 1. STATISTICS BY ROUND ==========
                csv += `STATISTIKA PO KRUGOVIMA\n`;
                csv += `Krug,Ime Igraƒça,Bodovi Ovaj Krug,Kumulativni Bodovi,! Kori≈°teno,. Kori≈°teno,? Kori≈°teno,Toƒçnih,Netoƒçnih,Avg Vrijeme/Pitanje\n`;
                
                // Track stats per round per player
                const roundStats = {};
                
                // Initialize round stats
                sortedPlayers.forEach(player => {
                    roundStats[player.id] = {};
                    for (let r = 1; r <= (settingsData.rounds?.length || 0); r++) {
                        roundStats[player.id][r] = {
                            points: 0,
                            cumulativePoints: 0,
                            exclamationUsed: 0,
                            periodUsed: 0,
                            lukavacUsed: 0,
                            correct: 0,
                            incorrect: 0,
                            totalTime: 0,
                            questionCount: 0
                        };
                    }
                });
                
                // Calculate round stats from history
                Object.entries(historyData).forEach(([playerId, playerHistory]) => {
                    Object.entries(playerHistory).forEach(([key, answerData]) => {
                        const round = answerData.round;
                        if (!roundStats[playerId] || !roundStats[playerId][round]) return;
                        
                        const roundIndex = round - 1;
                        const roundSettings = settingsData.rounds?.[roundIndex];
                        if (!roundSettings) return;
                        
                        const stats = roundStats[playerId][round];
                        
                        // Determine final answer
                        const finalAnswerIndex = answerData.finalAnswer !== undefined ? answerData.finalAnswer : answerData.answer;
                        const finalType = answerData.finalType || answerData.type;
                        
                        // Count type usage
                        if (finalType === 'exclamation') stats.exclamationUsed++;
                        else if (finalType === 'period') stats.periodUsed++;
                        else if (finalType === 'lukavac') stats.lukavacUsed++;
                        
                        // Get question to check if correct
                        const questionIndex = answerData.question - 1;
                        let questionIdx = 0;
                        for (let r = 0; r < roundIndex; r++) {
                            questionIdx += settingsData.rounds[r].questions || 10;
                        }
                        questionIdx += questionIndex;
                        
                        const question = questionsData[questionIdx];
                        if (question) {
                            const isCorrect = finalAnswerIndex === question.correct;
                            
                            if (isCorrect) {
                                stats.correct++;
                                if (finalType === 'exclamation') stats.points += roundSettings.values[0];
                                else if (finalType === 'period') stats.points += roundSettings.values[1];
                                else if (finalType === 'lukavac') stats.points += roundSettings.values[1];
                            } else {
                                stats.incorrect++;
                                if (finalType === 'exclamation') stats.points += roundSettings.values[4];
                                else if (finalType === 'period') stats.points += 0;
                                else if (finalType === 'lukavac') stats.points += roundSettings.values[3];
                            }
                        }
                        
                        // Track time
                        stats.totalTime += answerData.finalTimestamp || answerData.timestamp || 0;
                        stats.questionCount++;
                    });
                });
                
                // Calculate cumulative and output
                sortedPlayers.forEach(player => {
                    let cumulative = 0;
                    for (let r = 1; r <= (settingsData.rounds?.length || 0); r++) {
                        const stats = roundStats[player.id][r];
                        cumulative += stats.points;
                        stats.cumulativePoints = cumulative;
                        
                        const avgTime = stats.questionCount > 0 ? Math.round(stats.totalTime / stats.questionCount / 1000) : 0;
                        
                        csv += `${r},`;
                        csv += `"${escapeCSV(player.name || 'Unknown')}",`;
                        csv += `${stats.points >= 0 ? '+' : ''}${stats.points},`;
                        csv += `${stats.cumulativePoints},`;
                        csv += `${stats.exclamationUsed},`;
                        csv += `${stats.periodUsed},`;
                        csv += `${stats.lukavacUsed},`;
                        csv += `${stats.correct},`;
                        csv += `${stats.incorrect},`;
                        csv += `${avgTime}s\n`;
                    }
                });
                
                csv += `\n\n`;
                
                // ========== 2. ANSWER CHANGE TRACKING ==========
                csv += `PROMJENE ODGOVORA (LUKAVAC FAZA)\n`;
                csv += `Krug,Pitanje #,Ime Igraƒça,Poƒçetni Odgovor (Faza 1),Konaƒçni Odgovor (Faza 2),Promjena Tipa,Rezultat\n`;
                
                let changesCount = 0;
                Object.entries(historyData).forEach(([playerId, playerHistory]) => {
                    const player = playersData[playerId];
                    const playerName = player?.name || 'Unknown';
                    
                    Object.entries(playerHistory).forEach(([key, answerData]) => {
                        // Check if there was a change (finalAnswer exists)
                        if (answerData.finalAnswer === undefined) return;
                        
                        const round = answerData.round;
                        const questionNum = answerData.question;
                        
                        // Get question
                        const roundIndex = round - 1;
                        let questionIdx2 = 0;
                        for (let r = 0; r < roundIndex; r++) {
                            questionIdx2 += settingsData.rounds?.[r]?.questions || 10;
                        }
                        questionIdx2 += questionNum - 1;
                        
                        const question = questionsData[questionIdx2];
                        if (!question) return;
                        
                        // Initial answer
                        const initialAnswer = answerData.answer === -1 ? 'Lukavac' : 
                                            (question.answers[answerData.answer] || 'N/A');
                        const initialType = answerData.type === 'exclamation' ? '!' :
                                          answerData.type === 'period' ? '.' :
                                          answerData.type === 'lukavac' ? '?' : '-';
                        
                        // Final answer
                        const finalAnswer = question.answers[answerData.finalAnswer] || 'N/A';
                        const finalType = answerData.finalType === 'exclamation' ? '!' :
                                        answerData.finalType === 'period' ? '.' :
                                        answerData.finalType === 'lukavac' ? '?' : '-';
                        
                        // Did they change type?
                        const typeChange = initialType !== finalType ? `${initialType} ‚Üí ${finalType}` : 'Isti tip';
                        
                        // Was it correct?
                        const isCorrect = answerData.finalAnswer === question.correct;
                        const result = isCorrect ? 'Toƒçno ‚úì' : 'Netoƒçno ‚úó';
                        
                        csv += `${round},`;
                        csv += `${questionNum},`;
                        csv += `"${escapeCSV(playerName)}",`;
                        csv += `"${initialType} ${escapeCSV(initialAnswer)}",`;
                        csv += `"${finalType} ${escapeCSV(finalAnswer)}",`;
                        csv += `"${typeChange}",`;
                        csv += `${result}\n`;
                        changesCount++;
                    });
                });
                
                if (changesCount === 0) {
                    csv += `Nema promjena odgovora\n`;
                }
                
                csv += `\n\n`;
                
                // ========== 3. LEADERBOARD HISTORY ==========
                csv += `POVIJEST PORETKA PO KRUGOVIMA\n`;
                csv += `Krug,Ime Igraƒça,Rang,Bodovi,Promjena Ranga\n`;
                
                // Track rank history
                const rankHistory = {};
                
                for (let r = 1; r <= (settingsData.rounds?.length || 0); r++) {
                    // Calculate scores at end of round r
                    const scoresAtRound = sortedPlayers.map(player => ({
                        id: player.id,
                        name: player.name,
                        points: roundStats[player.id]?.[r]?.cumulativePoints || 0
                    }));
                    
                    // Sort by points
                    scoresAtRound.sort((a, b) => b.points - a.points);
                    
                    // Assign ranks and track changes
                    scoresAtRound.forEach((player, idx) => {
                        const currentRank = idx + 1;
                        const previousRank = rankHistory[player.id]?.rank || currentRank;
                        const rankChange = previousRank - currentRank; // Positive = moved up
                        
                        rankHistory[player.id] = { rank: currentRank, points: player.points };
                        
                        let changeText = '';
                        if (r === 1) {
                            changeText = 'Start';
                        } else if (rankChange > 0) {
                            changeText = `‚Üë +${rankChange}`;
                        } else if (rankChange < 0) {
                            changeText = `‚Üì ${rankChange}`;
                        } else {
                            changeText = '=';
                        }
                        
                        csv += `${r},`;
                        csv += `"${escapeCSV(player.name || 'Unknown')}",`;
                        csv += `${currentRank},`;
                        csv += `${player.points},`;
                        csv += `${changeText}\n`;
                    });
                }
                
                csv += `\n\n`;
                
                // ========== 4. QUESTION DIFFICULTY ANALYSIS ==========
                csv += `ANALIZA PITANJA (TE≈ΩINA)\n`;
                csv += `Krug,Pitanje #,Tekst Pitanja,Toƒçan Odgovor,Ukupno Odgovora,Toƒçnih,Netoƒçnih,% Toƒçnosti,Prosjeƒçni Bodovi,Te≈æina\n`;
                
                // Analyze each question
                let questionIdx3 = 0;
                for (let roundIdx = 0; roundIdx < (settingsData.rounds?.length || 0); roundIdx++) {
                    const round = settingsData.rounds[roundIdx];
                    const questionsInRound = round.questions || 10;
                    
                    for (let qInRound = 0; qInRound < questionsInRound && questionIdx3 < questionsData.length; qInRound++, questionIdx3++) {
                        const question = questionsData[questionIdx3];
                        const correctAnswerLetter = String.fromCharCode(65 + question.correct);
                        const correctAnswerText = question.answers[question.correct];
                        
                        let totalAnswers = 0;
                        let correctAnswers = 0;
                        let incorrectAnswers = 0;
                        let totalPoints = 0;
                        
                        // Count answers for this question
                        Object.entries(historyData).forEach(([playerId, playerHistory]) => {
                            const historyKey = `R${roundIdx + 1}Q${qInRound + 1}`;
                            const answerData = playerHistory[historyKey];
                            
                            if (answerData) {
                                totalAnswers++;
                                const finalAnswerIndex = answerData.finalAnswer !== undefined ? answerData.finalAnswer : answerData.answer;
                                const finalType = answerData.finalType || answerData.type;
                                
                                const isCorrect = finalAnswerIndex === question.correct;
                                if (isCorrect) {
                                    correctAnswers++;
                                    if (finalType === 'exclamation') totalPoints += round.values[0];
                                    else if (finalType === 'period') totalPoints += round.values[1];
                                    else if (finalType === 'lukavac') totalPoints += round.values[1];
                                } else {
                                    incorrectAnswers++;
                                    if (finalType === 'exclamation') totalPoints += round.values[4];
                                    else if (finalType === 'period') totalPoints += 0;
                                    else if (finalType === 'lukavac') totalPoints += round.values[3];
                                }
                            }
                        });
                        
                        const percentageCorrect = totalAnswers > 0 ? Math.round((correctAnswers / totalAnswers) * 100) : 0;
                        const avgPoints = totalAnswers > 0 ? Math.round(totalPoints / totalAnswers) : 0;
                        
                        // Difficulty rating
                        let difficulty = '';
                        if (percentageCorrect >= 80) difficulty = 'Lako ‚òÖ';
                        else if (percentageCorrect >= 60) difficulty = 'Srednje ‚òÖ‚òÖ';
                        else if (percentageCorrect >= 40) difficulty = 'Te≈°ko ‚òÖ‚òÖ‚òÖ';
                        else difficulty = 'Vrlo te≈°ko ‚òÖ‚òÖ‚òÖ‚òÖ';
                        
                        csv += `${roundIdx + 1},`;
                        csv += `${qInRound + 1},`;
                        csv += `"${escapeCSV(question.text)}",`;
                        csv += `"${correctAnswerLetter}. ${escapeCSV(correctAnswerText)}",`;
                        csv += `${totalAnswers},`;
                        csv += `${correctAnswers},`;
                        csv += `${incorrectAnswers},`;
                        csv += `${percentageCorrect}%,`;
                        csv += `${avgPoints >= 0 ? '+' : ''}${avgPoints},`;
                        csv += `${difficulty}\n`;
                    }
                }
                
                csv += `\n\n`;
                
                // ========== DOWNLOAD CSV ==========
                const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' }); // UTF-8 BOM for Excel
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const filename = `Lukavac_${settingsData.quizName || 'Kviz'}_${now.toISOString().split('T')[0]}.csv`;
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('‚úÖ CSV exported:', filename);
                showNotification('CSV izvje≈°taj preuzet! (' + filename + ')', 'success');
                
            } catch (error) {
                console.error('‚ùå Error exporting CSV:', error);
                showNotification('Gre≈°ka pri exportu CSV: ' + error.message, 'error');
            }
        }

        function escapeCSV(str) {
            if (str === null || str === undefined) return '';
            str = str.toString();
            // Escape quotes by doubling them
            str = str.replace(/"/g, '""');
            // Always wrap in quotes for safety
            return str;
        }

        function loadCSV() {
            const file = document.getElementById('csvFile').files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const lines = e.target.result.split('\n');
                const newQuestions = [];
                
                lines.forEach((line, idx) => {
                    if (idx === 0 || !line.trim()) return; // Skip header
                    const parts = line.split(',').map(s => s.trim());
                    if (parts.length >= 7 && parts[1]) {
                        newQuestions.push({
                            round: parseInt(parts[0]),
                            text: parts[1],
                            answers: [parts[2], parts[3], parts[4], parts[5]],
                            correct: parseInt(parts[6])
                        });
                    }
                });
                
                if (newQuestions.length > 0) {
                    database.ref('questions').set(newQuestions).then(() => {
                        alert(`‚úÖ Uƒçitano ${newQuestions.length} pitanja!`);
                    });
                } else {
                    alert('‚ùå Nema validnih pitanja u CSV fileu!');
                }
            };
            reader.readAsText(file);
        }

        function toggleAddQuestion() {
            const form = document.getElementById('addQuestionForm');
            const btn = document.getElementById('btnShowAddQuestion');
            if (form.classList.contains('hidden')) {
                form.classList.remove('hidden');
                btn.classList.add('hidden');
            } else {
                form.classList.add('hidden');
                btn.classList.remove('hidden');
            }
        }

        function updateQuestionsList() {
            const container = document.getElementById('questionsList');
            const count = document.getElementById('questionCount2');
            count.textContent = questions.length;
            
            if (questions.length === 0) {
                container.innerHTML = '<p class="text-gray-500">Nema dodanih pitanja</p>';
                return;
            }
            
            const html = questions.map((q, idx) => `
                <div class="p-2 bg-white rounded">
                    <span class="font-bold" style="color: #ea580c;">${idx + 1}.</span>
                    <span class="font-bold">Krug ${q.round}:</span>
                    ${q.text}
                    <span class="text-xs text-gray-600">(Toƒçno: ${String.fromCharCode(65 + q.correct)})</span>
                    <button onclick="deleteQuestion(${idx})" class="float-right text-red-600 hover:text-red-800 text-xs">üóëÔ∏è</button>
                </div>
            `).join('');
            container.innerHTML = html;
        }

        function deleteQuestion(index) {
            if (confirm('Obrisati ovo pitanje?')) {
                questions.splice(index, 1);
                database.ref('questions').set(questions);
            }
        }

        function addQuestionManually() {
            const text = document.getElementById('newQuestionText').value.trim();
            const answerA = document.getElementById('newAnswerA').value.trim();
            const answerB = document.getElementById('newAnswerB').value.trim();
            const answerC = document.getElementById('newAnswerC').value.trim();
            const answerD = document.getElementById('newAnswerD').value.trim();
            const round = parseInt(document.getElementById('newQuestionRound').value);
            const correct = parseInt(document.getElementById('newQuestionCorrect').value);

            if (!text || !answerA || !answerB || !answerC || !answerD) {
                alert('‚ùå Popuni sva polja!');
                return;
            }

            const newQuestion = {
                round: round,
                text: text,
                answers: [answerA, answerB, answerC, answerD],
                correct: correct
            };

            database.ref('questions').once('value').then(snap => {
                const existingQuestions = snap.val() || [];
                existingQuestions.push(newQuestion);
                database.ref('questions').set(existingQuestions).then(() => {
                    alert('‚úÖ Pitanje dodano!');
                    // Clear form
                    document.getElementById('newQuestionText').value = '';
                    document.getElementById('newAnswerA').value = '';
                    document.getElementById('newAnswerB').value = '';
                    document.getElementById('newAnswerC').value = '';
                    document.getElementById('newAnswerD').value = '';
                    toggleAddQuestion();
                });
            });
        }

        // Initialize default settings on first load
        database.ref('settings').once('value').then(snap => {
            if (!snap.val()) {
                database.ref('settings').set(defaultSettings);
            }
        });
        // ============================================
        // PLAYER MANAGEMENT FUNCTIONS
        // ============================================

        function updatePlayersManagement() {
            const tbody = document.getElementById('playersManagementList');
            
            if (Object.keys(players).length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center p-4 text-gray-500">Nema igraƒça</td></tr>';
                return;
            }

            // Sort players by score
            const sorted = Object.entries(players)
                .map(([id, data]) => ({ id, ...data }))
                .sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    if ((b.lukavacCount || 0) !== (a.lukavacCount || 0)) return (b.lukavacCount || 0) - (a.lukavacCount || 0);
                    if ((b.exclamationCount || 0) !== (a.exclamationCount || 0)) return (b.exclamationCount || 0) - (a.exclamationCount || 0);
                    return (a.totalTime || 0) - (b.totalTime || 0);
                });

            tbody.innerHTML = sorted.map((player, idx) => {
                const rating = player.rating || 0;
                return `
                    <tr class="border-b hover:bg-orange-50">
                        <td class="p-2 font-bold">${player.name || 'Unknown'}</td>
                        <td class="p-2 text-center font-bold" style="color: ${player.score > 0 ? '#10b981' : player.score < 0 ? '#ef4444' : '#6b7280'};">${player.score || 0}‚Ç¨</td>
                        <td class="p-2 text-center font-bold">#${idx + 1}</td>
                        <td class="p-2 text-center">${player.lukavacCount || 0}</td>
                        <td class="p-2 text-center">${player.exclamationCount || 0}</td>
                        <td class="p-2 text-center">
                            <select onchange="updatePlayerRating('${player.id}', this.value)" 
                                    class="border rounded px-2 py-1 text-sm"
                                    style="color: ${rating >= 7 ? '#10b981' : rating >= 5 ? '#d97706' : '#ef4444'};">
                                <option value="0" ${rating === 0 ? 'selected' : ''}>-</option>
                                ${[1,2,3,4,5,6,7,8,9,10].map(n => 
                                    `<option value="${n}" ${rating === n ? 'selected' : ''}>${n}</option>`
                                ).join('')}
                            </select>
                        </td>
                        <td class="p-2 text-center">
                            <button onclick="kickPlayer('${player.id}', '${player.name}')" 
                                    class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm font-bold">
                                ‚ùå Izbaci
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updatePlayerRating(playerId, rating) {
            const ratingValue = parseInt(rating);
            database.ref(`players/${playerId}/rating`).set(ratingValue)
                .then(() => {
                    console.log(`‚úÖ Player ${playerId} rating updated to ${ratingValue}`);
                    // Show feedback
                    showNotification(`Ocjena postavljena: ${ratingValue}/10`, 'success');
                })
                .catch(error => {
                    console.error('‚ùå Error updating rating:', error);
                    showNotification('Gre≈°ka pri postavljanju ocjene', 'error');
                });
        }

        function kickPlayer(playerId, playerName) {
            if (!confirm(`Sigurno ≈æeli≈° izbaciti igraƒça "${playerName}" iz kviza?\n\nOva akcija je TRAJNA i igraƒç se neƒáe moƒái vratiti u ovu igru.`)) {
                return;
            }

            console.log(`üö´ Kicking player: ${playerId} (${playerName})`);

            // Remove player from players list
            database.ref(`players/${playerId}`).remove()
                .then(() => {
                    console.log('‚úÖ Player removed from players list');
                    
                    // Remove player's answers
                    return database.ref(`answers/${playerId}`).remove();
                })
                .then(() => {
                    console.log('‚úÖ Player answers removed');
                    
                    // Add to kicked list (permanent ban for this game)
                    return database.ref(`kicked/${playerId}`).set({
                        name: playerName,
                        timestamp: Date.now(),
                        kickedBy: 'admin'
                    });
                })
                .then(() => {
                    console.log('‚úÖ Player added to kicked list');
                    showNotification(`Igraƒç "${playerName}" je izbaƒçen iz kviza`, 'success');
                })
                .catch(error => {
                    console.error('‚ùå Error kicking player:', error);
                    showNotification('Gre≈°ka pri izbacivanju igraƒça', 'error');
                });
        }

        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white font-bold`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // ============================================
        // CSV EXPORT FUNCTION
        // ============================================


    </script>
</body>
</html>